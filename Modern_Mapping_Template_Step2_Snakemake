import os
import os.path
from os import listdir
from os.path import isfile, join



################################################################################################################ SET UP ################################################################################################################

SAMPLES=[]
SORTED_SAMPLES=[]
DIR_LOC={}
LIBS_TO_SAMPLE={}

if os.path.exists(METADATA):
    META_DATA_FILE=open('METADATA','r')

BAM_FOLDERS=['./']


### Find the location of all 'sorted' BAM files
for BAM_PATH in BAM_FOLDERS:

    BAM_FILES = [f for f in listdir(BAM_PATH) if isfile(join(BAM_PATH, f))]
    BAM_FILES = [f for f in BAM_FILES if '.sorted' in f]
    
    for FILE in BAM_FILES:
    
        SAMPLE_HERE=FILE.split('.sorted')[0]
        DIR_LOC[SAMPLE_HERE]=BAM_PATH.replace('./','')
        SORTED_SAMPLES.append(SAMPLE_HERE)



SORTED_SAMPLES_WITH_NO_MERGING=[]

### Use metadata to link individual libraries to their sample

#### Read METADATA header
if os.path.exists(METADATA):
    META_DATA_FILE.readline()


    #### Read METADATA file, create Dictionary

    for LINE in META_DATA_FILE:
        
        LINE=LINE.strip().split()
        # print(LINE)
        SAMPLE_HERE=LINE[1]
        SORTED_HERE=LINE[3]
        SORTED_SAMPLES_WITH_NO_MERGING.append(SORTED_HERE)
        
        if SAMPLE_HERE in LIBS_TO_SAMPLE.keys():
            LIBS_TO_SAMPLE[SAMPLE_HERE].append(SORTED_HERE)
        else:
            LIBS_TO_SAMPLE[SAMPLE_HERE]=[SORTED_HERE]
            SAMPLES.append(SAMPLE_HERE)



#### If sorted but only one , will still try to merge

SORTED_SAMPLES_WITH_NO_MERGING=[X for X in SORTED_SAMPLES if X not in SORTED_SAMPLES_WITH_NO_MERGING]
for X in SORTED_SAMPLES_WITH_NO_MERGING:
    LIBS_TO_SAMPLE[X]=[X]



###### FINAL FILES SET UP
SORTED_SAMPLES=list(set(SORTED_SAMPLES))
SAMPLES=list(set(SAMPLES))





###### Print number of samples
SAMPLES=SAMPLES[0:3] ############################### TESTING! ##########################################################################################################################################################################################


##### Print out Each sample and its corresponding sorted bam files

for S in SAMPLES:
    print(S,LIBS_TO_SAMPLE[S])




print(f'Number of Sorted BAM files to be processed :  {len(SORTED_SAMPLES)}')
print('Number of Samples they correspond to :  ',len(SAMPLES))


######## Get full path of Sorted Sample

def LocationOfSortedSample(SortedSample):
    return "{}{}.sorted".format(DIR_LOC[SortedSample],SortedSample)


########### Function to return list of sorted files corresponding to each sample

def GetSortedForSample(Sample):

    SORTED_BAMS=LIBS_TO_SAMPLE[Sample]
    SORTED_BAMS=[ LocationOfSortedSample(X) for X in SORTED_BAMS ]
    # SORTED_BAMS=','.join(SORTED_BAMS)
    return SORTED_BAMS


###### One Rule to Rule them ALL

rule all:
    input:
        expand("{sample}.combined", sample=SAMPLES),
        # expand("FINISHED/{sample}.bam", sample=SAMPLES),
        # expand("FINISHED/{sample}.bam.bai", sample=SAMPLES)







##### Merge bams corresponding to same individual


################################################################################## LIBRARY MERGING AND FINAL FILTERING #################################################################################################################

rule Combine_Same_Sample_Bams:
    input:
        SORTED_BAMS= lambda wildcards: GetSortedForSample(wildcards.sample)
    output:
        COMBINED=temp('{sample}.combined')
    threads: 4
    run:
        RENAMED_SORTED_BAMS=' '.join(input.SORTED_BAMS)
        shell('samtools merge --threads {threads} -o {output.COMBINED} -f {input.SORTED_BAMS}')



rule samtools_remove_dupl_bam:
    input:
        SORTED_BAM="{sample}.combined"
    output:
        MARKED_BAM=temp("{sample}.marked")
    threads: 4
    shell:
        "samtools markdup --mode t -S -r -@ {threads} {input.SORTED_BAM} {output.MARKED_BAM}"



rule samtools_final_filter_bam:
    input:
        MARKED_BAM="{sample}.marked"
    output:
        FILTERED_BAM="{sample}.filtered"
    threads: 4
    shell:
        "samtools view -@ {threads} -q 30 -F 0x404 -b -o {output.FILTERED_BAM} {input.MARKED_BAM}"




rule samtools_index:
    input:
        FILTERED_BAM="{sample}.filtered"
    output:
        BAI="{sample}.filtered.bai"
    threads: 4
    shell:
        "samtools index -b {input.FILTERED_BAM} -@ {threads}"




rule rename_files:
    input:
        FILTERED_BAM="{sample}.filtered",
        FILTERED_BAI="{sample}.filtered.bai"
    output:
        RENAMED_BAM="{sample}.bam",
        RENAMED_BAI="{sample}.bam.bai"
    run:
        shell("mv {input.FILTERED_BAM} {output.RENAMED_BAM}")
        shell("mv {input.FILTERED_BAI} {output.RENAMED_BAI}")






# rule create_folder_and_move_files_in:
    # input:
        # RENAMED_BAM="{sample}.bam",
        # RENAMED_BAI="{sample}.bam.bai"
    # output:
        # MOVED_BAM="FINISHED/{sample}.bam",
        # MOVED_BAI="FINISHED/{sample}.bam.bai"
        
    # run:
        ##### check if folder 'FINISHED' exists , if not create items
        #### if (os.path.exists('FINISHED')==True):
        #### else:
        #### now move files into folder
        #### shell('mv {RENAMED_BAM} {MOVED_BAM}')
        #### shell('mv {RENAMED_BAI} {MOVED_BAI}')