import os
import os.path
from os import listdir
from os.path import isfile, join

################################################################################################################################################################################################################################################################################################################################################
################################################################### USEFULL FUNCTIONS
######## GET LOCATION OF SAMPLE




def LocationOfPairedSample1(Sample):
    return "{}{}_1.fastq.gz".format(DIR_LOC[Sample],Sample)
    
def LocationOfPairedSample2(Sample):
    return "{}{}_2.fastq.gz".format(DIR_LOC[Sample],Sample)

def LocationOfNonPairedSample(Sample):
    return "{}{}.fastq.gz".format(DIR_LOC[Sample],Sample)

########### DECIDE WHICH PATH OF THE PIPELINE TO TAKE: PAIR END OR NOT 

def SAM_PE_OR_NOT(Sample):

    if PAIRED_END[Sample]=='YES':
        FILE="{}_PE.sam".format(Sample)
    if PAIRED_END[Sample]=='NO':
        FILE="{}_NONPE.sam".format(Sample)
        
    return FILE


######## Get full path of Sorted Sample

def LocationOfSortedSample(SortedSample):
    return "{}{}.sorted".format(DIR_LOC[SortedSample],SortedSample)



########### Function to return list of sorted files corresponding to each sample

def GetSortedForSample(Sample):
    
    
    
    
    
    SORTED_BAMS=LIBS_TO_SAMPLE[Sample]
    SORTED_BAMS=[ LocationOfSortedSample(X) for X in SORTED_BAMS ]
    return SORTED_BAMS














################################################################################################################ SET UP ################################################################################################################################################################################################################################







SAMPLES=[]
SORTED_SAMPLES=[]
DIR_LOC={}
DIR_LOC_SORTED={}
PAIRED_END={}
FASTQ_FOLDERS=['../PONGO_STUDY_FASTQ/'] ##### Set by user
LIBS_TO_SAMPLE={}

if os.path.exists('METADATA'):
    META_DATA_FILE=open('METADATA','r')

BAM_FOLDERS=['./']














for FASTQ_PATH in FASTQ_FOLDERS: #### Find which samples exist in fastq folder, make 'library'of them and at which format they exist

    FASTQ_FILES = [f for f in listdir(FASTQ_PATH) if isfile(join(FASTQ_PATH, f))]
    FASTQ_FILES = [f for f in FASTQ_FILES if '.fastq' in f]
    for FILE in FASTQ_FILES:
    
        SAMPLE_HERE=FILE.split('.fastq')[0]
        
        if (SAMPLE_HERE[len(SAMPLE_HERE)-2:len(SAMPLE_HERE)]=='_1') or (SAMPLE_HERE[len(SAMPLE_HERE)-2:len(SAMPLE_HERE)]=='_2'):
            SAMPLE_HERE=FILE.split('_1.fastq')[0]
            SAMPLE_HERE=SAMPLE_HERE.split('_2.fastq')[0]
            DIR_LOC[SAMPLE_HERE]=FASTQ_PATH
            PAIRED_END[SAMPLE_HERE]='YES'
            SAMPLES.append(SAMPLE_HERE)
            
        else :
            DIR_LOC[SAMPLE_HERE]=FASTQ_PATH
            PAIRED_END[SAMPLE_HERE]='NO'
            SAMPLES.append(SAMPLE_HERE)



SAMPLES=list(set(SAMPLES))
print(len(SAMPLES))
###SAMPLES=SAMPLES[0:2] ############################### TESTING!





### Use metadata to link individual libraries to their sample

#### Read METADATA header ######################## This should be called as a function, for rule "Combine_Same_Sample_Bams", 
                                          ######## It should look at the METADATA file and find which fastq samples correspond to the sample.
                                          ######## Then its should check to see if any of them exists in the Fastq folder!



# if os.path.exists('METADATA'): ##### Should check labels of METADATA file to see if the required ones are there and in which order
    # META_DATA_FILE.readline()


    ### Read METADATA file, create Dictionary

    # for LINE in META_DATA_FILE:
        
        # LINE=LINE.strip().split()
        # print(LINE)
        # SAMPLE_HERE=LINE[1]
        # SORTED_HERE=LINE[3]
        # SORTED_SAMPLES_WITH_NO_MERGING.append(SORTED_HERE)
        
        # if SAMPLE_HERE in LIBS_TO_SAMPLE.keys():
            # LIBS_TO_SAMPLE[SAMPLE_HERE].append(SORTED_HERE)
        # else:
            # LIBS_TO_SAMPLE[SAMPLE_HERE]=[SORTED_HERE]
            # SAMPLES.append(SAMPLE_HERE)



### If sorted but only one , will still try to merge

# SORTED_SAMPLES_WITH_NO_MERGING=[X for X in SORTED_SAMPLES if X not in SORTED_SAMPLES_WITH_NO_MERGING]
# for X in SORTED_SAMPLES_WITH_NO_MERGING:
    # LIBS_TO_SAMPLE[X]=[X]



##### FINAL FILES SET UP
# SORTED_SAMPLES=sorted(list(set(SORTED_SAMPLES)))
# SAMPLES=sorted(list(set(SAMPLES)))

































############################################################################################################################################################################################################################################################


####### FINAL FILES SET UP
SAMPLES=set(SAMPLES)
REF_LOC='../../REFERENCE_GENOMES/'  ############ Set by User
REF=REF_LOC+'Pongo_abelii.Susie_PABv2.dna.toplevel.fa' ############ Set by User

for S in SAMPLES:
    print(S,PAIRED_END[S],DIR_LOC[S])

###### One Rule to Rule them ALL

rule all:
    input:
        REF+'.bwt',
        expand("{sample}.sorted", sample=SAMPLES),###### Initial Sorting Step
        #expand("{sample}.bam", sample=SAMPLES),    ############## Combined into samples
        #expand("{sample}.bam.bai", sample=SAMPLES) ############ Combined into samples





######################################################################################################################
#### REF PREP

rule Index_Reference:
    input:
        REF
    output:
        REF+'.bwt'
    shell:
        "bwa index {input}"
        
        


###################################################################################################################### SAMPLE PREP ############################################################################################################################

###### PE
rule Adapter_trimming_PE:
    input:
        r1=lambda wildcards: LocationOfPairedSample1(wildcards.sample),
        r2=lambda wildcards: LocationOfPairedSample2(wildcards.sample)

    output:
        o1=temp('{sample}_1_FASTP.fastq.gz'),
        o2=temp('{sample}_2_FASTP.fastq.gz')
    threads: 16
    shell:
        "fastp -i {input.r1} -I {input.r2} -o {output.o1}  -O {output.o2} --length_required 30  --thread {threads}"



######## NON PE

rule Adapter_trimming_NON_PE:
    input:
        R= lambda wildcards: LocationOfNonPairedSample(wildcards.sample)
    output:
        TR=temp("{sample}.trimmed.fastq.gz")
    threads: 16
    shell:
        "fastp -i {input.R} -o {output.TR} --length_required 30 --thread {threads}"










########################################################################################################################### ALIGNMENT ###########################################################################################################################

######## PE 
rule BWA_PE_aln_1:
    input:
        r1='{sample}_1_FASTP.fastq.gz',
        R=REF,
        RI=REF+'.bwt'
    output:
        o1=temp("{sample}_1.sai")
    threads: 16
    shell:
        "bwa aln -t {threads} {input.R} {input.r1} > {output.o1}"
   


rule BWA_PE_aln_2:
    input:
        r2='{sample}_2_FASTP.fastq.gz',
        R=REF,
        RI=REF+'.bwt'
    output:
        o2=temp("{sample}_2.sai")
    threads: 16
    shell:
        "bwa aln -t {threads} {input.R} {input.r2} > {output.o2}"



rule BWA_PE_sampe:
    input:
        r1="{sample}_1.sai",
        r2="{sample}_2.sai",
        raw1='{sample}_1_FASTP.fastq.gz',
        raw2='{sample}_2_FASTP.fastq.gz',
        R=REF,
        RI=REF+'.bwt'
    output:
        SAM=temp("{sample}_PE.sam")
    threads: 16
    shell:
        "bwa sampe {input.R} {input.r1} {input.r2} {input.raw1} {input.raw2} > {output.SAM}"



######## NON PE 


rule BWA_aln_NON_PE:
    input:
        TR="{sample}.trimmed.fastq.gz",
        R=REF,
        RI=REF+'.bwt'
    output:
        SAI=temp("{sample}.sai")
    threads: 16
    shell:
        "bwa aln -t {threads} {input.R} {input.TR} > {output.SAI}"
    

rule BWA_samse_NON_PE:
    input:
        SAI="{sample}.sai",
        R=REF,
        RI=REF+'.bwt',
        TR="{sample}.trimmed.fastq.gz"
    output:
        SAM=temp("{sample}_NONPE.sam")
    shell:
        "bwa samse {input.R} {input.SAI} {input.TR} > {output.SAM}"










################################################################################## BAM CONVERSION AND CLEAN-UP $#################################################################################################################







rule samtools_convert_to_bam:
    input:
        SAM=lambda wildcards: SAM_PE_OR_NOT(wildcards.sample)
    output:
        BAM=temp("{sample}.initial")
    threads: 4
    shell:
        "samtools view -S --threads={threads} -b {input.SAM} > {output.BAM}"


rule samtools_fix_bam:
    input:
        BAM="{sample}.initial"
    output:
        FIXED_BAM=temp("{sample}.fixed")
    threads: 4
    shell:
        "samtools fixmate -@ {threads} -m {input.BAM} {output.FIXED_BAM}"


rule samtools_sort:
    input:
        FIXED_BAM="{sample}.fixed"
    output:
        SORTED_BAM="{sample}.sorted"
    threads: 4
    shell:
        "samtools sort {input.FIXED_BAM}  -@ {threads} -o {output.SORTED_BAM}"









################################################################################## LIBRARY MERGING AND FINAL FILTERING #################################################################################################################

### Merge Different BAM files if they correspond to the same sample

rule Combine_Same_Sample_Bams:
    input:
        SORTED_BAMS= lambda wildcards: GetSortedForSample(wildcards.sample)
    output:
        COMBINED=temp('{sample}.combined')
    threads: 4
    run:
        RENAMED_SORTED_BAMS=' '.join(input.SORTED_BAMS)
        shell('samtools merge --threads {threads} -o {output.COMBINED} -f {input.SORTED_BAMS}')


### Markdup BAM files for different things: Mark supplementary reads of duplicates as duplicates, remove duplicates

rule samtools_markedup_bam:
    input:
        SORTED_BAM="{sample}.combined"
    output:
        MARKED_BAM=temp("{sample}.marked")
    threads: 4
    shell:
        "samtools markdup --mode t -S -r -@ {threads} {input.SORTED_BAM} {output.MARKED_BAM}"


### Filter BAM files for MAPQ of >30 and 

rule samtools_final_filter_bam:
    input:
        MARKED_BAM="{sample}.marked"
    output:
        FILTERED_BAM="{sample}.filtered"
    threads: 4
    shell:
        "samtools view -@ {threads} -q 15 -F 0x404 -b -o {output.FILTERED_BAM} {input.MARKED_BAM}"


### Index the final bam file


rule samtools_index:
    input:
        FILTERED_BAM="{sample}.filtered"
    output:
        BAI="{sample}.filtered.bai"
    threads: 4
    shell:
        "samtools index -b {input.FILTERED_BAM} -@ {threads}"


### Rename the BAM file

rule rename_files:
    input:
        FILTERED_BAM="{sample}.filtered",
        FILTERED_BAI="{sample}.filtered.bai"
    output:
        RENAMED_BAM="{sample}.bam",
        RENAMED_BAI="{sample}.bam.bai"
    run:
        shell("mv {input.FILTERED_BAM} {output.RENAMED_BAM}")
        shell("mv {input.FILTERED_BAI} {output.RENAMED_BAI}")